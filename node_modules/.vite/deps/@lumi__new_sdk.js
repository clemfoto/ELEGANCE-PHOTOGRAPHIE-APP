import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-PR4QN5HX.js";

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof global !== "undefined" && global.crypto) {
          crypto2 = global.crypto;
        }
        if (!crypto2 && typeof __require === "function") {
          try {
            crypto2 = require_crypto();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || /* @__PURE__ */ function() {
          function F2() {
          }
          return function(obj) {
            var subtype;
            F2.prototype = obj;
            subtype = new F2();
            F2.prototype = null;
            return subtype;
          };
        }();
        var C2 = {};
        var C_lib = C2.lib = {};
        var Base = C_lib.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j2 = 0; j2 < thatSigBytes; j2 += 4) {
                thisWords[thisSigBytes + j2 >>> 2] = thatWords[j2 >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C2.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C2.algo = {};
        return C2;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/crypto-js/enc-base64.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C2.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j2 = 0; j2 < 4 && i + j2 * 0.75 < sigBytes; j2++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j2) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j2 = 0; j2 < map.length; j2++) {
                reverseMap[map.charCodeAt(j2)] = j2;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// node_modules/crypto-js/enc-hex.js
var require_enc_hex = __commonJS({
  "node_modules/crypto-js/enc-hex.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS.enc.Hex;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var H2 = [];
        var K2 = [];
        (function() {
          function isPrime(n3) {
            var sqrtN = Math2.sqrt(n3);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n3 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n3) {
            return (n3 - (n3 | 0)) * 4294967296 | 0;
          }
          var n2 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n2)) {
              if (nPrime < 8) {
                H2[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 2));
              }
              K2[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 3));
              nPrime++;
            }
            n2++;
          }
        })();
        var W2 = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H2.slice(0));
          },
          _doProcessBlock: function(M2, offset) {
            var H3 = this._hash.words;
            var a2 = H3[0];
            var b2 = H3[1];
            var c2 = H3[2];
            var d = H3[3];
            var e = H3[4];
            var f2 = H3[5];
            var g2 = H3[6];
            var h = H3[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W2[i] = M2[offset + i] | 0;
              } else {
                var gamma0x = W2[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W2[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W2[i] = gamma0 + W2[i - 7] + gamma1 + W2[i - 16];
              }
              var ch = e & f2 ^ ~e & g2;
              var maj = a2 & b2 ^ a2 & c2 ^ b2 & c2;
              var sigma0 = (a2 << 30 | a2 >>> 2) ^ (a2 << 19 | a2 >>> 13) ^ (a2 << 10 | a2 >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K2[i] + W2[i];
              var t2 = sigma0 + maj;
              h = g2;
              g2 = f2;
              f2 = e;
              e = d + t1 | 0;
              d = c2;
              c2 = b2;
              b2 = a2;
              a2 = t1 + t2 | 0;
            }
            H3[0] = H3[0] + a2 | 0;
            H3[1] = H3[1] + b2 | 0;
            H3[2] = H3[2] + c2 | 0;
            H3[3] = H3[3] + d | 0;
            H3[4] = H3[4] + e | 0;
            H3[5] = H3[5] + f2 | 0;
            H3[6] = H3[6] + g2 | 0;
            H3[7] = H3[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C2.SHA256 = Hasher._createHelper(SHA256);
        C2.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// node_modules/crypto-js/hmac.js
var require_hmac = __commonJS({
  "node_modules/crypto-js/hmac.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base = C_lib.Base;
        var C_enc = C2.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C2.algo;
        var HMAC = C_algo.HMAC = Base.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i = 0; i < hasherBlockSize; i++) {
              oKeyWords[i] ^= 1549556828;
              iKeyWords[i] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
  }
});

// node_modules/crypto-js/hmac-sha256.js
var require_hmac_sha256 = __commonJS({
  "node_modules/crypto-js/hmac-sha256.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS.HmacSHA256;
    });
  }
});

// node_modules/object-hash/dist/object_hash.js
var require_object_hash = __commonJS({
  "node_modules/object-hash/dist/object_hash.js"(exports, module) {
    !function(e) {
      var t;
      "object" == typeof exports ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : ("undefined" != typeof window ? t = window : "undefined" != typeof global ? t = global : "undefined" != typeof self && (t = self), t.objectHash = e());
    }(function() {
      return function r2(o, i, u2) {
        function s(n2, e2) {
          if (!i[n2]) {
            if (!o[n2]) {
              var t = "function" == typeof __require && __require;
              if (!e2 && t) return t(n2, true);
              if (a2) return a2(n2, true);
              throw new Error("Cannot find module '" + n2 + "'");
            }
            e2 = i[n2] = { exports: {} };
            o[n2][0].call(e2.exports, function(e3) {
              var t2 = o[n2][1][e3];
              return s(t2 || e3);
            }, e2, e2.exports, r2, o, i, u2);
          }
          return i[n2].exports;
        }
        for (var a2 = "function" == typeof __require && __require, e = 0; e < u2.length; e++) s(u2[e]);
        return s;
      }({ 1: [function(w, b2, m2) {
        !(function(e, n2, s, c2, d, h, p, g2, y2) {
          "use strict";
          var r2 = w("crypto");
          function t(e2, t2) {
            t2 = u2(e2, t2);
            var n3;
            return void 0 === (n3 = "passthrough" !== t2.algorithm ? r2.createHash(t2.algorithm) : new l()).write && (n3.write = n3.update, n3.end = n3.update), f2(t2, n3).dispatch(e2), n3.update || n3.end(""), n3.digest ? n3.digest("buffer" === t2.encoding ? void 0 : t2.encoding) : (e2 = n3.read(), "buffer" !== t2.encoding ? e2.toString(t2.encoding) : e2);
          }
          (m2 = b2.exports = t).sha1 = function(e2) {
            return t(e2);
          }, m2.keys = function(e2) {
            return t(e2, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
          }, m2.MD5 = function(e2) {
            return t(e2, { algorithm: "md5", encoding: "hex" });
          }, m2.keysMD5 = function(e2) {
            return t(e2, { algorithm: "md5", encoding: "hex", excludeValues: true });
          };
          var o = r2.getHashes ? r2.getHashes().slice() : ["sha1", "md5"], i = (o.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
          function u2(e2, t2) {
            var n3 = {};
            if (n3.algorithm = (t2 = t2 || {}).algorithm || "sha1", n3.encoding = t2.encoding || "hex", n3.excludeValues = !!t2.excludeValues, n3.algorithm = n3.algorithm.toLowerCase(), n3.encoding = n3.encoding.toLowerCase(), n3.ignoreUnknown = true === t2.ignoreUnknown, n3.respectType = false !== t2.respectType, n3.respectFunctionNames = false !== t2.respectFunctionNames, n3.respectFunctionProperties = false !== t2.respectFunctionProperties, n3.unorderedArrays = true === t2.unorderedArrays, n3.unorderedSets = false !== t2.unorderedSets, n3.unorderedObjects = false !== t2.unorderedObjects, n3.replacer = t2.replacer || void 0, n3.excludeKeys = t2.excludeKeys || void 0, void 0 === e2) throw new Error("Object argument required.");
            for (var r3 = 0; r3 < o.length; ++r3) o[r3].toLowerCase() === n3.algorithm.toLowerCase() && (n3.algorithm = o[r3]);
            if (-1 === o.indexOf(n3.algorithm)) throw new Error('Algorithm "' + n3.algorithm + '"  not supported. supported values: ' + o.join(", "));
            if (-1 === i.indexOf(n3.encoding) && "passthrough" !== n3.algorithm) throw new Error('Encoding "' + n3.encoding + '"  not supported. supported values: ' + i.join(", "));
            return n3;
          }
          function a2(e2) {
            if ("function" == typeof e2) return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e2));
          }
          function f2(o2, t2, i2) {
            i2 = i2 || [];
            function u3(e2) {
              return t2.update ? t2.update(e2, "utf8") : t2.write(e2, "utf8");
            }
            return { dispatch: function(e2) {
              return this["_" + (null === (e2 = o2.replacer ? o2.replacer(e2) : e2) ? "null" : typeof e2)](e2);
            }, _object: function(t3) {
              var n3, e2 = Object.prototype.toString.call(t3), r3 = /\[object (.*)\]/i.exec(e2);
              r3 = (r3 = r3 ? r3[1] : "unknown:[" + e2 + "]").toLowerCase();
              if (0 <= (e2 = i2.indexOf(t3))) return this.dispatch("[CIRCULAR:" + e2 + "]");
              if (i2.push(t3), void 0 !== s && s.isBuffer && s.isBuffer(t3)) return u3("buffer:"), u3(t3);
              if ("object" === r3 || "function" === r3 || "asyncfunction" === r3) return e2 = Object.keys(t3), o2.unorderedObjects && (e2 = e2.sort()), false === o2.respectType || a2(t3) || e2.splice(0, 0, "prototype", "__proto__", "constructor"), o2.excludeKeys && (e2 = e2.filter(function(e3) {
                return !o2.excludeKeys(e3);
              })), u3("object:" + e2.length + ":"), n3 = this, e2.forEach(function(e3) {
                n3.dispatch(e3), u3(":"), o2.excludeValues || n3.dispatch(t3[e3]), u3(",");
              });
              if (!this["_" + r3]) {
                if (o2.ignoreUnknown) return u3("[" + r3 + "]");
                throw new Error('Unknown object type "' + r3 + '"');
              }
              this["_" + r3](t3);
            }, _array: function(e2, t3) {
              t3 = void 0 !== t3 ? t3 : false !== o2.unorderedArrays;
              var n3 = this;
              if (u3("array:" + e2.length + ":"), !t3 || e2.length <= 1) return e2.forEach(function(e3) {
                return n3.dispatch(e3);
              });
              var r3 = [], t3 = e2.map(function(e3) {
                var t4 = new l(), n4 = i2.slice();
                return f2(o2, t4, n4).dispatch(e3), r3 = r3.concat(n4.slice(i2.length)), t4.read().toString();
              });
              return i2 = i2.concat(r3), t3.sort(), this._array(t3, false);
            }, _date: function(e2) {
              return u3("date:" + e2.toJSON());
            }, _symbol: function(e2) {
              return u3("symbol:" + e2.toString());
            }, _error: function(e2) {
              return u3("error:" + e2.toString());
            }, _boolean: function(e2) {
              return u3("bool:" + e2.toString());
            }, _string: function(e2) {
              u3("string:" + e2.length + ":"), u3(e2.toString());
            }, _function: function(e2) {
              u3("fn:"), a2(e2) ? this.dispatch("[native]") : this.dispatch(e2.toString()), false !== o2.respectFunctionNames && this.dispatch("function-name:" + String(e2.name)), o2.respectFunctionProperties && this._object(e2);
            }, _number: function(e2) {
              return u3("number:" + e2.toString());
            }, _xml: function(e2) {
              return u3("xml:" + e2.toString());
            }, _null: function() {
              return u3("Null");
            }, _undefined: function() {
              return u3("Undefined");
            }, _regexp: function(e2) {
              return u3("regex:" + e2.toString());
            }, _uint8array: function(e2) {
              return u3("uint8array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _uint8clampedarray: function(e2) {
              return u3("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _int8array: function(e2) {
              return u3("int8array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _uint16array: function(e2) {
              return u3("uint16array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _int16array: function(e2) {
              return u3("int16array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _uint32array: function(e2) {
              return u3("uint32array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _int32array: function(e2) {
              return u3("int32array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _float32array: function(e2) {
              return u3("float32array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _float64array: function(e2) {
              return u3("float64array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _arraybuffer: function(e2) {
              return u3("arraybuffer:"), this.dispatch(new Uint8Array(e2));
            }, _url: function(e2) {
              return u3("url:" + e2.toString());
            }, _map: function(e2) {
              u3("map:");
              e2 = Array.from(e2);
              return this._array(e2, false !== o2.unorderedSets);
            }, _set: function(e2) {
              u3("set:");
              e2 = Array.from(e2);
              return this._array(e2, false !== o2.unorderedSets);
            }, _file: function(e2) {
              return u3("file:"), this.dispatch([e2.name, e2.size, e2.type, e2.lastModfied]);
            }, _blob: function() {
              if (o2.ignoreUnknown) return u3("[blob]");
              throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
            }, _domwindow: function() {
              return u3("domwindow");
            }, _bigint: function(e2) {
              return u3("bigint:" + e2.toString());
            }, _process: function() {
              return u3("process");
            }, _timer: function() {
              return u3("timer");
            }, _pipe: function() {
              return u3("pipe");
            }, _tcp: function() {
              return u3("tcp");
            }, _udp: function() {
              return u3("udp");
            }, _tty: function() {
              return u3("tty");
            }, _statwatcher: function() {
              return u3("statwatcher");
            }, _securecontext: function() {
              return u3("securecontext");
            }, _connection: function() {
              return u3("connection");
            }, _zlib: function() {
              return u3("zlib");
            }, _context: function() {
              return u3("context");
            }, _nodescript: function() {
              return u3("nodescript");
            }, _httpparser: function() {
              return u3("httpparser");
            }, _dataview: function() {
              return u3("dataview");
            }, _signal: function() {
              return u3("signal");
            }, _fsevent: function() {
              return u3("fsevent");
            }, _tlswrap: function() {
              return u3("tlswrap");
            } };
          }
          function l() {
            return { buf: "", write: function(e2) {
              this.buf += e2;
            }, end: function(e2) {
              this.buf += e2;
            }, read: function() {
              return this.buf;
            } };
          }
          m2.writeToStream = function(e2, t2, n3) {
            return void 0 === n3 && (n3 = t2, t2 = {}), f2(t2 = u2(e2, t2), n3).dispatch(e2);
          };
        }).call(this, w("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
      }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(e, t, f2) {
        !(function(e2, t2, n2, r2, o, i, u2, s, a2) {
          !function(e3) {
            "use strict";
            var a3 = "undefined" != typeof Uint8Array ? Uint8Array : Array, t3 = "+".charCodeAt(0), n3 = "/".charCodeAt(0), r3 = "0".charCodeAt(0), o2 = "a".charCodeAt(0), i2 = "A".charCodeAt(0), u3 = "-".charCodeAt(0), s2 = "_".charCodeAt(0);
            function f3(e4) {
              e4 = e4.charCodeAt(0);
              return e4 === t3 || e4 === u3 ? 62 : e4 === n3 || e4 === s2 ? 63 : e4 < r3 ? -1 : e4 < r3 + 10 ? e4 - r3 + 26 + 26 : e4 < i2 + 26 ? e4 - i2 : e4 < o2 + 26 ? e4 - o2 + 26 : void 0;
            }
            e3.toByteArray = function(e4) {
              var t4, n4;
              if (0 < e4.length % 4) throw new Error("Invalid string. Length must be a multiple of 4");
              var r4 = e4.length, r4 = "=" === e4.charAt(r4 - 2) ? 2 : "=" === e4.charAt(r4 - 1) ? 1 : 0, o3 = new a3(3 * e4.length / 4 - r4), i3 = 0 < r4 ? e4.length - 4 : e4.length, u4 = 0;
              function s3(e5) {
                o3[u4++] = e5;
              }
              for (t4 = 0; t4 < i3; t4 += 4, 0) s3((16711680 & (n4 = f3(e4.charAt(t4)) << 18 | f3(e4.charAt(t4 + 1)) << 12 | f3(e4.charAt(t4 + 2)) << 6 | f3(e4.charAt(t4 + 3)))) >> 16), s3((65280 & n4) >> 8), s3(255 & n4);
              return 2 == r4 ? s3(255 & (n4 = f3(e4.charAt(t4)) << 2 | f3(e4.charAt(t4 + 1)) >> 4)) : 1 == r4 && (s3((n4 = f3(e4.charAt(t4)) << 10 | f3(e4.charAt(t4 + 1)) << 4 | f3(e4.charAt(t4 + 2)) >> 2) >> 8 & 255), s3(255 & n4)), o3;
            }, e3.fromByteArray = function(e4) {
              var t4, n4, r4, o3, i3 = e4.length % 3, u4 = "";
              function s3(e5) {
                return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e5);
              }
              for (t4 = 0, r4 = e4.length - i3; t4 < r4; t4 += 3) n4 = (e4[t4] << 16) + (e4[t4 + 1] << 8) + e4[t4 + 2], u4 += s3((o3 = n4) >> 18 & 63) + s3(o3 >> 12 & 63) + s3(o3 >> 6 & 63) + s3(63 & o3);
              switch (i3) {
                case 1:
                  u4 = (u4 += s3((n4 = e4[e4.length - 1]) >> 2)) + s3(n4 << 4 & 63) + "==";
                  break;
                case 2:
                  u4 = (u4 = (u4 += s3((n4 = (e4[e4.length - 2] << 8) + e4[e4.length - 1]) >> 10)) + s3(n4 >> 4 & 63)) + s3(n4 << 2 & 63) + "=";
              }
              return u4;
            };
          }(void 0 === f2 ? this.base64js = {} : f2);
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
      }, { buffer: 3, lYpoI2: 11 }], 3: [function(O2, e, H2) {
        !(function(e2, n2, f2, r2, h, p, g2, y2, w) {
          var a2 = O2("base64-js"), i = O2("ieee754");
          function f2(e3, t2, n3) {
            if (!(this instanceof f2)) return new f2(e3, t2, n3);
            var r3, o2, i2, u3, s2 = typeof e3;
            if ("base64" === t2 && "string" == s2) for (e3 = (u3 = e3).trim ? u3.trim() : u3.replace(/^\s+|\s+$/g, ""); e3.length % 4 != 0; ) e3 += "=";
            if ("number" == s2) r3 = j2(e3);
            else if ("string" == s2) r3 = f2.byteLength(e3, t2);
            else {
              if ("object" != s2) throw new Error("First argument needs to be a number, array or string.");
              r3 = j2(e3.length);
            }
            if (f2._useTypedArrays ? o2 = f2._augment(new Uint8Array(r3)) : ((o2 = this).length = r3, o2._isBuffer = true), f2._useTypedArrays && "number" == typeof e3.byteLength) o2._set(e3);
            else if (C2(u3 = e3) || f2.isBuffer(u3) || u3 && "object" == typeof u3 && "number" == typeof u3.length) for (i2 = 0; i2 < r3; i2++) f2.isBuffer(e3) ? o2[i2] = e3.readUInt8(i2) : o2[i2] = e3[i2];
            else if ("string" == s2) o2.write(e3, 0, t2);
            else if ("number" == s2 && !f2._useTypedArrays && !n3) for (i2 = 0; i2 < r3; i2++) o2[i2] = 0;
            return o2;
          }
          function b2(e3, t2, n3, r3) {
            return f2._charsWritten = c2(function(e4) {
              for (var t3 = [], n4 = 0; n4 < e4.length; n4++) t3.push(255 & e4.charCodeAt(n4));
              return t3;
            }(t2), e3, n3, r3);
          }
          function m2(e3, t2, n3, r3) {
            return f2._charsWritten = c2(function(e4) {
              for (var t3, n4, r4 = [], o2 = 0; o2 < e4.length; o2++) n4 = e4.charCodeAt(o2), t3 = n4 >> 8, n4 = n4 % 256, r4.push(n4), r4.push(t3);
              return r4;
            }(t2), e3, n3, r3);
          }
          function v2(e3, t2, n3) {
            var r3 = "";
            n3 = Math.min(e3.length, n3);
            for (var o2 = t2; o2 < n3; o2++) r3 += String.fromCharCode(e3[o2]);
            return r3;
          }
          function o(e3, t2, n3, r3) {
            r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(null != t2, "missing offset"), d(t2 + 1 < e3.length, "Trying to read beyond buffer length"));
            var o2, r3 = e3.length;
            if (!(r3 <= t2)) return n3 ? (o2 = e3[t2], t2 + 1 < r3 && (o2 |= e3[t2 + 1] << 8)) : (o2 = e3[t2] << 8, t2 + 1 < r3 && (o2 |= e3[t2 + 1])), o2;
          }
          function u2(e3, t2, n3, r3) {
            r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(null != t2, "missing offset"), d(t2 + 3 < e3.length, "Trying to read beyond buffer length"));
            var o2, r3 = e3.length;
            if (!(r3 <= t2)) return n3 ? (t2 + 2 < r3 && (o2 = e3[t2 + 2] << 16), t2 + 1 < r3 && (o2 |= e3[t2 + 1] << 8), o2 |= e3[t2], t2 + 3 < r3 && (o2 += e3[t2 + 3] << 24 >>> 0)) : (t2 + 1 < r3 && (o2 = e3[t2 + 1] << 16), t2 + 2 < r3 && (o2 |= e3[t2 + 2] << 8), t2 + 3 < r3 && (o2 |= e3[t2 + 3]), o2 += e3[t2] << 24 >>> 0), o2;
          }
          function _2(e3, t2, n3, r3) {
            if (r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(null != t2, "missing offset"), d(t2 + 1 < e3.length, "Trying to read beyond buffer length")), !(e3.length <= t2)) return r3 = o(e3, t2, n3, true), 32768 & r3 ? -1 * (65535 - r3 + 1) : r3;
          }
          function E2(e3, t2, n3, r3) {
            if (r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(null != t2, "missing offset"), d(t2 + 3 < e3.length, "Trying to read beyond buffer length")), !(e3.length <= t2)) return r3 = u2(e3, t2, n3, true), 2147483648 & r3 ? -1 * (4294967295 - r3 + 1) : r3;
          }
          function I2(e3, t2, n3, r3) {
            return r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(t2 + 3 < e3.length, "Trying to read beyond buffer length")), i.read(e3, t2, n3, 23, 4);
          }
          function A(e3, t2, n3, r3) {
            return r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(t2 + 7 < e3.length, "Trying to read beyond buffer length")), i.read(e3, t2, n3, 52, 8);
          }
          function s(e3, t2, n3, r3, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 1 < e3.length, "trying to write beyond buffer length"), Y2(t2, 65535));
            o2 = e3.length;
            if (!(o2 <= n3)) for (var i2 = 0, u3 = Math.min(o2 - n3, 2); i2 < u3; i2++) e3[n3 + i2] = (t2 & 255 << 8 * (r3 ? i2 : 1 - i2)) >>> 8 * (r3 ? i2 : 1 - i2);
          }
          function l(e3, t2, n3, r3, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 3 < e3.length, "trying to write beyond buffer length"), Y2(t2, 4294967295));
            o2 = e3.length;
            if (!(o2 <= n3)) for (var i2 = 0, u3 = Math.min(o2 - n3, 4); i2 < u3; i2++) e3[n3 + i2] = t2 >>> 8 * (r3 ? i2 : 3 - i2) & 255;
          }
          function B2(e3, t2, n3, r3, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 1 < e3.length, "Trying to write beyond buffer length"), F2(t2, 32767, -32768)), e3.length <= n3 || s(e3, 0 <= t2 ? t2 : 65535 + t2 + 1, n3, r3, o2);
          }
          function L2(e3, t2, n3, r3, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 3 < e3.length, "Trying to write beyond buffer length"), F2(t2, 2147483647, -2147483648)), e3.length <= n3 || l(e3, 0 <= t2 ? t2 : 4294967295 + t2 + 1, n3, r3, o2);
          }
          function U2(e3, t2, n3, r3, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 3 < e3.length, "Trying to write beyond buffer length"), D2(t2, 34028234663852886e22, -34028234663852886e22)), e3.length <= n3 || i.write(e3, t2, n3, r3, 23, 4);
          }
          function x2(e3, t2, n3, r3, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 7 < e3.length, "Trying to write beyond buffer length"), D2(t2, 17976931348623157e292, -17976931348623157e292)), e3.length <= n3 || i.write(e3, t2, n3, r3, 52, 8);
          }
          H2.Buffer = f2, H2.SlowBuffer = f2, H2.INSPECT_MAX_BYTES = 50, f2.poolSize = 8192, f2._useTypedArrays = function() {
            try {
              var e3 = new ArrayBuffer(0), t2 = new Uint8Array(e3);
              return t2.foo = function() {
                return 42;
              }, 42 === t2.foo() && "function" == typeof t2.subarray;
            } catch (e4) {
              return false;
            }
          }(), f2.isEncoding = function(e3) {
            switch (String(e3).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "raw":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, f2.isBuffer = function(e3) {
            return !(null == e3 || !e3._isBuffer);
          }, f2.byteLength = function(e3, t2) {
            var n3;
            switch (e3 += "", t2 || "utf8") {
              case "hex":
                n3 = e3.length / 2;
                break;
              case "utf8":
              case "utf-8":
                n3 = T(e3).length;
                break;
              case "ascii":
              case "binary":
              case "raw":
                n3 = e3.length;
                break;
              case "base64":
                n3 = M2(e3).length;
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                n3 = 2 * e3.length;
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return n3;
          }, f2.concat = function(e3, t2) {
            if (d(C2(e3), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e3.length) return new f2(0);
            if (1 === e3.length) return e3[0];
            if ("number" != typeof t2) for (o2 = t2 = 0; o2 < e3.length; o2++) t2 += e3[o2].length;
            for (var n3 = new f2(t2), r3 = 0, o2 = 0; o2 < e3.length; o2++) {
              var i2 = e3[o2];
              i2.copy(n3, r3), r3 += i2.length;
            }
            return n3;
          }, f2.prototype.write = function(e3, t2, n3, r3) {
            isFinite(t2) ? isFinite(n3) || (r3 = n3, n3 = void 0) : (a3 = r3, r3 = t2, t2 = n3, n3 = a3), t2 = Number(t2) || 0;
            var o2, i2, u3, s2, a3 = this.length - t2;
            switch ((!n3 || a3 < (n3 = Number(n3))) && (n3 = a3), r3 = String(r3 || "utf8").toLowerCase()) {
              case "hex":
                o2 = function(e4, t3, n4, r4) {
                  n4 = Number(n4) || 0;
                  var o3 = e4.length - n4;
                  (!r4 || o3 < (r4 = Number(r4))) && (r4 = o3), d((o3 = t3.length) % 2 == 0, "Invalid hex string"), o3 / 2 < r4 && (r4 = o3 / 2);
                  for (var i3 = 0; i3 < r4; i3++) {
                    var u4 = parseInt(t3.substr(2 * i3, 2), 16);
                    d(!isNaN(u4), "Invalid hex string"), e4[n4 + i3] = u4;
                  }
                  return f2._charsWritten = 2 * i3, i3;
                }(this, e3, t2, n3);
                break;
              case "utf8":
              case "utf-8":
                i2 = this, u3 = t2, s2 = n3, o2 = f2._charsWritten = c2(T(e3), i2, u3, s2);
                break;
              case "ascii":
              case "binary":
                o2 = b2(this, e3, t2, n3);
                break;
              case "base64":
                i2 = this, u3 = t2, s2 = n3, o2 = f2._charsWritten = c2(M2(e3), i2, u3, s2);
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                o2 = m2(this, e3, t2, n3);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return o2;
          }, f2.prototype.toString = function(e3, t2, n3) {
            var r3, o2, i2, u3, s2 = this;
            if (e3 = String(e3 || "utf8").toLowerCase(), t2 = Number(t2) || 0, (n3 = void 0 !== n3 ? Number(n3) : s2.length) === t2) return "";
            switch (e3) {
              case "hex":
                r3 = function(e4, t3, n4) {
                  var r4 = e4.length;
                  (!t3 || t3 < 0) && (t3 = 0);
                  (!n4 || n4 < 0 || r4 < n4) && (n4 = r4);
                  for (var o3 = "", i3 = t3; i3 < n4; i3++) o3 += k2(e4[i3]);
                  return o3;
                }(s2, t2, n3);
                break;
              case "utf8":
              case "utf-8":
                r3 = function(e4, t3, n4) {
                  var r4 = "", o3 = "";
                  n4 = Math.min(e4.length, n4);
                  for (var i3 = t3; i3 < n4; i3++) e4[i3] <= 127 ? (r4 += N2(o3) + String.fromCharCode(e4[i3]), o3 = "") : o3 += "%" + e4[i3].toString(16);
                  return r4 + N2(o3);
                }(s2, t2, n3);
                break;
              case "ascii":
              case "binary":
                r3 = v2(s2, t2, n3);
                break;
              case "base64":
                o2 = s2, u3 = n3, r3 = 0 === (i2 = t2) && u3 === o2.length ? a2.fromByteArray(o2) : a2.fromByteArray(o2.slice(i2, u3));
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                r3 = function(e4, t3, n4) {
                  for (var r4 = e4.slice(t3, n4), o3 = "", i3 = 0; i3 < r4.length; i3 += 2) o3 += String.fromCharCode(r4[i3] + 256 * r4[i3 + 1]);
                  return o3;
                }(s2, t2, n3);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return r3;
          }, f2.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          }, f2.prototype.copy = function(e3, t2, n3, r3) {
            if (t2 = t2 || 0, (r3 = r3 || 0 === r3 ? r3 : this.length) !== (n3 = n3 || 0) && 0 !== e3.length && 0 !== this.length) {
              d(n3 <= r3, "sourceEnd < sourceStart"), d(0 <= t2 && t2 < e3.length, "targetStart out of bounds"), d(0 <= n3 && n3 < this.length, "sourceStart out of bounds"), d(0 <= r3 && r3 <= this.length, "sourceEnd out of bounds"), r3 > this.length && (r3 = this.length);
              var o2 = (r3 = e3.length - t2 < r3 - n3 ? e3.length - t2 + n3 : r3) - n3;
              if (o2 < 100 || !f2._useTypedArrays) for (var i2 = 0; i2 < o2; i2++) e3[i2 + t2] = this[i2 + n3];
              else e3._set(this.subarray(n3, n3 + o2), t2);
            }
          }, f2.prototype.slice = function(e3, t2) {
            var n3 = this.length;
            if (e3 = S(e3, n3, 0), t2 = S(t2, n3, n3), f2._useTypedArrays) return f2._augment(this.subarray(e3, t2));
            for (var r3 = t2 - e3, o2 = new f2(r3, void 0, true), i2 = 0; i2 < r3; i2++) o2[i2] = this[i2 + e3];
            return o2;
          }, f2.prototype.get = function(e3) {
            return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e3);
          }, f2.prototype.set = function(e3, t2) {
            return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e3, t2);
          }, f2.prototype.readUInt8 = function(e3, t2) {
            if (t2 || (d(null != e3, "missing offset"), d(e3 < this.length, "Trying to read beyond buffer length")), !(e3 >= this.length)) return this[e3];
          }, f2.prototype.readUInt16LE = function(e3, t2) {
            return o(this, e3, true, t2);
          }, f2.prototype.readUInt16BE = function(e3, t2) {
            return o(this, e3, false, t2);
          }, f2.prototype.readUInt32LE = function(e3, t2) {
            return u2(this, e3, true, t2);
          }, f2.prototype.readUInt32BE = function(e3, t2) {
            return u2(this, e3, false, t2);
          }, f2.prototype.readInt8 = function(e3, t2) {
            if (t2 || (d(null != e3, "missing offset"), d(e3 < this.length, "Trying to read beyond buffer length")), !(e3 >= this.length)) return 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
          }, f2.prototype.readInt16LE = function(e3, t2) {
            return _2(this, e3, true, t2);
          }, f2.prototype.readInt16BE = function(e3, t2) {
            return _2(this, e3, false, t2);
          }, f2.prototype.readInt32LE = function(e3, t2) {
            return E2(this, e3, true, t2);
          }, f2.prototype.readInt32BE = function(e3, t2) {
            return E2(this, e3, false, t2);
          }, f2.prototype.readFloatLE = function(e3, t2) {
            return I2(this, e3, true, t2);
          }, f2.prototype.readFloatBE = function(e3, t2) {
            return I2(this, e3, false, t2);
          }, f2.prototype.readDoubleLE = function(e3, t2) {
            return A(this, e3, true, t2);
          }, f2.prototype.readDoubleBE = function(e3, t2) {
            return A(this, e3, false, t2);
          }, f2.prototype.writeUInt8 = function(e3, t2, n3) {
            n3 || (d(null != e3, "missing value"), d(null != t2, "missing offset"), d(t2 < this.length, "trying to write beyond buffer length"), Y2(e3, 255)), t2 >= this.length || (this[t2] = e3);
          }, f2.prototype.writeUInt16LE = function(e3, t2, n3) {
            s(this, e3, t2, true, n3);
          }, f2.prototype.writeUInt16BE = function(e3, t2, n3) {
            s(this, e3, t2, false, n3);
          }, f2.prototype.writeUInt32LE = function(e3, t2, n3) {
            l(this, e3, t2, true, n3);
          }, f2.prototype.writeUInt32BE = function(e3, t2, n3) {
            l(this, e3, t2, false, n3);
          }, f2.prototype.writeInt8 = function(e3, t2, n3) {
            n3 || (d(null != e3, "missing value"), d(null != t2, "missing offset"), d(t2 < this.length, "Trying to write beyond buffer length"), F2(e3, 127, -128)), t2 >= this.length || (0 <= e3 ? this.writeUInt8(e3, t2, n3) : this.writeUInt8(255 + e3 + 1, t2, n3));
          }, f2.prototype.writeInt16LE = function(e3, t2, n3) {
            B2(this, e3, t2, true, n3);
          }, f2.prototype.writeInt16BE = function(e3, t2, n3) {
            B2(this, e3, t2, false, n3);
          }, f2.prototype.writeInt32LE = function(e3, t2, n3) {
            L2(this, e3, t2, true, n3);
          }, f2.prototype.writeInt32BE = function(e3, t2, n3) {
            L2(this, e3, t2, false, n3);
          }, f2.prototype.writeFloatLE = function(e3, t2, n3) {
            U2(this, e3, t2, true, n3);
          }, f2.prototype.writeFloatBE = function(e3, t2, n3) {
            U2(this, e3, t2, false, n3);
          }, f2.prototype.writeDoubleLE = function(e3, t2, n3) {
            x2(this, e3, t2, true, n3);
          }, f2.prototype.writeDoubleBE = function(e3, t2, n3) {
            x2(this, e3, t2, false, n3);
          }, f2.prototype.fill = function(e3, t2, n3) {
            if (t2 = t2 || 0, n3 = n3 || this.length, d("number" == typeof (e3 = "string" == typeof (e3 = e3 || 0) ? e3.charCodeAt(0) : e3) && !isNaN(e3), "value is not a number"), d(t2 <= n3, "end < start"), n3 !== t2 && 0 !== this.length) {
              d(0 <= t2 && t2 < this.length, "start out of bounds"), d(0 <= n3 && n3 <= this.length, "end out of bounds");
              for (var r3 = t2; r3 < n3; r3++) this[r3] = e3;
            }
          }, f2.prototype.inspect = function() {
            for (var e3 = [], t2 = this.length, n3 = 0; n3 < t2; n3++) if (e3[n3] = k2(this[n3]), n3 === H2.INSPECT_MAX_BYTES) {
              e3[n3 + 1] = "...";
              break;
            }
            return "<Buffer " + e3.join(" ") + ">";
          }, f2.prototype.toArrayBuffer = function() {
            if ("undefined" == typeof Uint8Array) throw new Error("Buffer.toArrayBuffer not supported in this browser");
            if (f2._useTypedArrays) return new f2(this).buffer;
            for (var e3 = new Uint8Array(this.length), t2 = 0, n3 = e3.length; t2 < n3; t2 += 1) e3[t2] = this[t2];
            return e3.buffer;
          };
          var t = f2.prototype;
          function S(e3, t2, n3) {
            return "number" != typeof e3 ? n3 : t2 <= (e3 = ~~e3) ? t2 : 0 <= e3 || 0 <= (e3 += t2) ? e3 : 0;
          }
          function j2(e3) {
            return (e3 = ~~Math.ceil(+e3)) < 0 ? 0 : e3;
          }
          function C2(e3) {
            return (Array.isArray || function(e4) {
              return "[object Array]" === Object.prototype.toString.call(e4);
            })(e3);
          }
          function k2(e3) {
            return e3 < 16 ? "0" + e3.toString(16) : e3.toString(16);
          }
          function T(e3) {
            for (var t2 = [], n3 = 0; n3 < e3.length; n3++) {
              var r3 = e3.charCodeAt(n3);
              if (r3 <= 127) t2.push(e3.charCodeAt(n3));
              else for (var o2 = n3, i2 = (55296 <= r3 && r3 <= 57343 && n3++, encodeURIComponent(e3.slice(o2, n3 + 1)).substr(1).split("%")), u3 = 0; u3 < i2.length; u3++) t2.push(parseInt(i2[u3], 16));
            }
            return t2;
          }
          function M2(e3) {
            return a2.toByteArray(e3);
          }
          function c2(e3, t2, n3, r3) {
            for (var o2 = 0; o2 < r3 && !(o2 + n3 >= t2.length || o2 >= e3.length); o2++) t2[o2 + n3] = e3[o2];
            return o2;
          }
          function N2(e3) {
            try {
              return decodeURIComponent(e3);
            } catch (e4) {
              return String.fromCharCode(65533);
            }
          }
          function Y2(e3, t2) {
            d("number" == typeof e3, "cannot write a non-number as a number"), d(0 <= e3, "specified a negative value for writing an unsigned value"), d(e3 <= t2, "value is larger than maximum value for type"), d(Math.floor(e3) === e3, "value has a fractional component");
          }
          function F2(e3, t2, n3) {
            d("number" == typeof e3, "cannot write a non-number as a number"), d(e3 <= t2, "value larger than maximum allowed value"), d(n3 <= e3, "value smaller than minimum allowed value"), d(Math.floor(e3) === e3, "value has a fractional component");
          }
          function D2(e3, t2, n3) {
            d("number" == typeof e3, "cannot write a non-number as a number"), d(e3 <= t2, "value larger than maximum allowed value"), d(n3 <= e3, "value smaller than minimum allowed value");
          }
          function d(e3, t2) {
            if (!e3) throw new Error(t2 || "Failed assertion");
          }
          f2._augment = function(e3) {
            return e3._isBuffer = true, e3._get = e3.get, e3._set = e3.set, e3.get = t.get, e3.set = t.set, e3.write = t.write, e3.toString = t.toString, e3.toLocaleString = t.toString, e3.toJSON = t.toJSON, e3.copy = t.copy, e3.slice = t.slice, e3.readUInt8 = t.readUInt8, e3.readUInt16LE = t.readUInt16LE, e3.readUInt16BE = t.readUInt16BE, e3.readUInt32LE = t.readUInt32LE, e3.readUInt32BE = t.readUInt32BE, e3.readInt8 = t.readInt8, e3.readInt16LE = t.readInt16LE, e3.readInt16BE = t.readInt16BE, e3.readInt32LE = t.readInt32LE, e3.readInt32BE = t.readInt32BE, e3.readFloatLE = t.readFloatLE, e3.readFloatBE = t.readFloatBE, e3.readDoubleLE = t.readDoubleLE, e3.readDoubleBE = t.readDoubleBE, e3.writeUInt8 = t.writeUInt8, e3.writeUInt16LE = t.writeUInt16LE, e3.writeUInt16BE = t.writeUInt16BE, e3.writeUInt32LE = t.writeUInt32LE, e3.writeUInt32BE = t.writeUInt32BE, e3.writeInt8 = t.writeInt8, e3.writeInt16LE = t.writeInt16LE, e3.writeInt16BE = t.writeInt16BE, e3.writeInt32LE = t.writeInt32LE, e3.writeInt32BE = t.writeInt32BE, e3.writeFloatLE = t.writeFloatLE, e3.writeFloatBE = t.writeFloatBE, e3.writeDoubleLE = t.writeDoubleLE, e3.writeDoubleBE = t.writeDoubleBE, e3.fill = t.fill, e3.inspect = t.inspect, e3.toArrayBuffer = t.toArrayBuffer, e3;
          };
        }).call(this, O2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, O2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
      }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(c2, d, e) {
        !(function(e2, t, a2, n2, r2, o, i, u2, s) {
          var a2 = c2("buffer").Buffer, f2 = 4, l = new a2(f2);
          l.fill(0);
          d.exports = { hash: function(e3, t2, n3, r3) {
            for (var o2 = t2(function(e4, t3) {
              e4.length % f2 != 0 && (n4 = e4.length + (f2 - e4.length % f2), e4 = a2.concat([e4, l], n4));
              for (var n4, r4 = [], o3 = t3 ? e4.readInt32BE : e4.readInt32LE, i3 = 0; i3 < e4.length; i3 += f2) r4.push(o3.call(e4, i3));
              return r4;
            }(e3 = a2.isBuffer(e3) ? e3 : new a2(e3), r3), 8 * e3.length), t2 = r3, i2 = new a2(n3), u3 = t2 ? i2.writeInt32BE : i2.writeInt32LE, s2 = 0; s2 < o2.length; s2++) u3.call(i2, o2[s2], 4 * s2, true);
            return i2;
          } };
        }).call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 5: [function(v2, e, _2) {
        !(function(l, c2, u2, d, h, p, g2, y2, w) {
          var u2 = v2("buffer").Buffer, e2 = v2("./sha"), t = v2("./sha256"), n2 = v2("./rng"), b2 = { sha1: e2, sha256: t, md5: v2("./md5") }, s = 64, a2 = new u2(s);
          function r2(e3, n3) {
            var r3 = b2[e3 = e3 || "sha1"], o2 = [];
            return r3 || i("algorithm:", e3, "is not yet supported"), { update: function(e4) {
              return u2.isBuffer(e4) || (e4 = new u2(e4)), o2.push(e4), e4.length, this;
            }, digest: function(e4) {
              var t2 = u2.concat(o2), t2 = n3 ? function(e5, t3, n4) {
                u2.isBuffer(t3) || (t3 = new u2(t3)), u2.isBuffer(n4) || (n4 = new u2(n4)), t3.length > s ? t3 = e5(t3) : t3.length < s && (t3 = u2.concat([t3, a2], s));
                for (var r4 = new u2(s), o3 = new u2(s), i2 = 0; i2 < s; i2++) r4[i2] = 54 ^ t3[i2], o3[i2] = 92 ^ t3[i2];
                return n4 = e5(u2.concat([r4, n4])), e5(u2.concat([o3, n4]));
              }(r3, n3, t2) : r3(t2);
              return o2 = null, e4 ? t2.toString(e4) : t2;
            } };
          }
          function i() {
            var e3 = [].slice.call(arguments).join(" ");
            throw new Error([e3, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
          }
          a2.fill(0), _2.createHash = function(e3) {
            return r2(e3);
          }, _2.createHmac = r2, _2.randomBytes = function(e3, t2) {
            if (!t2 || !t2.call) return new u2(n2(e3));
            try {
              t2.call(this, void 0, new u2(n2(e3)));
            } catch (e4) {
              t2(e4);
            }
          };
          var o, f2 = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], m2 = function(e3) {
            _2[e3] = function() {
              i("sorry,", e3, "is not implemented yet");
            };
          };
          for (o in f2) m2(f2[o], o);
        }).call(this, v2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, v2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(w, b2, e) {
        !(function(e2, r2, o, i, u2, a2, f2, l, y2) {
          var t = w("./helpers");
          function n2(e3, t2) {
            e3[t2 >> 5] |= 128 << t2 % 32, e3[14 + (t2 + 64 >>> 9 << 4)] = t2;
            for (var n3 = 1732584193, r3 = -271733879, o2 = -1732584194, i2 = 271733878, u3 = 0; u3 < e3.length; u3 += 16) {
              var s2 = n3, a3 = r3, f3 = o2, l2 = i2, n3 = c2(n3, r3, o2, i2, e3[u3 + 0], 7, -680876936), i2 = c2(i2, n3, r3, o2, e3[u3 + 1], 12, -389564586), o2 = c2(o2, i2, n3, r3, e3[u3 + 2], 17, 606105819), r3 = c2(r3, o2, i2, n3, e3[u3 + 3], 22, -1044525330);
              n3 = c2(n3, r3, o2, i2, e3[u3 + 4], 7, -176418897), i2 = c2(i2, n3, r3, o2, e3[u3 + 5], 12, 1200080426), o2 = c2(o2, i2, n3, r3, e3[u3 + 6], 17, -1473231341), r3 = c2(r3, o2, i2, n3, e3[u3 + 7], 22, -45705983), n3 = c2(n3, r3, o2, i2, e3[u3 + 8], 7, 1770035416), i2 = c2(i2, n3, r3, o2, e3[u3 + 9], 12, -1958414417), o2 = c2(o2, i2, n3, r3, e3[u3 + 10], 17, -42063), r3 = c2(r3, o2, i2, n3, e3[u3 + 11], 22, -1990404162), n3 = c2(n3, r3, o2, i2, e3[u3 + 12], 7, 1804603682), i2 = c2(i2, n3, r3, o2, e3[u3 + 13], 12, -40341101), o2 = c2(o2, i2, n3, r3, e3[u3 + 14], 17, -1502002290), n3 = d(n3, r3 = c2(r3, o2, i2, n3, e3[u3 + 15], 22, 1236535329), o2, i2, e3[u3 + 1], 5, -165796510), i2 = d(i2, n3, r3, o2, e3[u3 + 6], 9, -1069501632), o2 = d(o2, i2, n3, r3, e3[u3 + 11], 14, 643717713), r3 = d(r3, o2, i2, n3, e3[u3 + 0], 20, -373897302), n3 = d(n3, r3, o2, i2, e3[u3 + 5], 5, -701558691), i2 = d(i2, n3, r3, o2, e3[u3 + 10], 9, 38016083), o2 = d(o2, i2, n3, r3, e3[u3 + 15], 14, -660478335), r3 = d(r3, o2, i2, n3, e3[u3 + 4], 20, -405537848), n3 = d(n3, r3, o2, i2, e3[u3 + 9], 5, 568446438), i2 = d(i2, n3, r3, o2, e3[u3 + 14], 9, -1019803690), o2 = d(o2, i2, n3, r3, e3[u3 + 3], 14, -187363961), r3 = d(r3, o2, i2, n3, e3[u3 + 8], 20, 1163531501), n3 = d(n3, r3, o2, i2, e3[u3 + 13], 5, -1444681467), i2 = d(i2, n3, r3, o2, e3[u3 + 2], 9, -51403784), o2 = d(o2, i2, n3, r3, e3[u3 + 7], 14, 1735328473), n3 = h(n3, r3 = d(r3, o2, i2, n3, e3[u3 + 12], 20, -1926607734), o2, i2, e3[u3 + 5], 4, -378558), i2 = h(i2, n3, r3, o2, e3[u3 + 8], 11, -2022574463), o2 = h(o2, i2, n3, r3, e3[u3 + 11], 16, 1839030562), r3 = h(r3, o2, i2, n3, e3[u3 + 14], 23, -35309556), n3 = h(n3, r3, o2, i2, e3[u3 + 1], 4, -1530992060), i2 = h(i2, n3, r3, o2, e3[u3 + 4], 11, 1272893353), o2 = h(o2, i2, n3, r3, e3[u3 + 7], 16, -155497632), r3 = h(r3, o2, i2, n3, e3[u3 + 10], 23, -1094730640), n3 = h(n3, r3, o2, i2, e3[u3 + 13], 4, 681279174), i2 = h(i2, n3, r3, o2, e3[u3 + 0], 11, -358537222), o2 = h(o2, i2, n3, r3, e3[u3 + 3], 16, -722521979), r3 = h(r3, o2, i2, n3, e3[u3 + 6], 23, 76029189), n3 = h(n3, r3, o2, i2, e3[u3 + 9], 4, -640364487), i2 = h(i2, n3, r3, o2, e3[u3 + 12], 11, -421815835), o2 = h(o2, i2, n3, r3, e3[u3 + 15], 16, 530742520), n3 = p(n3, r3 = h(r3, o2, i2, n3, e3[u3 + 2], 23, -995338651), o2, i2, e3[u3 + 0], 6, -198630844), i2 = p(i2, n3, r3, o2, e3[u3 + 7], 10, 1126891415), o2 = p(o2, i2, n3, r3, e3[u3 + 14], 15, -1416354905), r3 = p(r3, o2, i2, n3, e3[u3 + 5], 21, -57434055), n3 = p(n3, r3, o2, i2, e3[u3 + 12], 6, 1700485571), i2 = p(i2, n3, r3, o2, e3[u3 + 3], 10, -1894986606), o2 = p(o2, i2, n3, r3, e3[u3 + 10], 15, -1051523), r3 = p(r3, o2, i2, n3, e3[u3 + 1], 21, -2054922799), n3 = p(n3, r3, o2, i2, e3[u3 + 8], 6, 1873313359), i2 = p(i2, n3, r3, o2, e3[u3 + 15], 10, -30611744), o2 = p(o2, i2, n3, r3, e3[u3 + 6], 15, -1560198380), r3 = p(r3, o2, i2, n3, e3[u3 + 13], 21, 1309151649), n3 = p(n3, r3, o2, i2, e3[u3 + 4], 6, -145523070), i2 = p(i2, n3, r3, o2, e3[u3 + 11], 10, -1120210379), o2 = p(o2, i2, n3, r3, e3[u3 + 2], 15, 718787259), r3 = p(r3, o2, i2, n3, e3[u3 + 9], 21, -343485551), n3 = g2(n3, s2), r3 = g2(r3, a3), o2 = g2(o2, f3), i2 = g2(i2, l2);
            }
            return Array(n3, r3, o2, i2);
          }
          function s(e3, t2, n3, r3, o2, i2) {
            return g2((t2 = g2(g2(t2, e3), g2(r3, i2))) << o2 | t2 >>> 32 - o2, n3);
          }
          function c2(e3, t2, n3, r3, o2, i2, u3) {
            return s(t2 & n3 | ~t2 & r3, e3, t2, o2, i2, u3);
          }
          function d(e3, t2, n3, r3, o2, i2, u3) {
            return s(t2 & r3 | n3 & ~r3, e3, t2, o2, i2, u3);
          }
          function h(e3, t2, n3, r3, o2, i2, u3) {
            return s(t2 ^ n3 ^ r3, e3, t2, o2, i2, u3);
          }
          function p(e3, t2, n3, r3, o2, i2, u3) {
            return s(n3 ^ (t2 | ~r3), e3, t2, o2, i2, u3);
          }
          function g2(e3, t2) {
            var n3 = (65535 & e3) + (65535 & t2);
            return (e3 >> 16) + (t2 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
          }
          b2.exports = function(e3) {
            return t.hash(e3, n2, 16);
          };
        }).call(this, w("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(e, l, t) {
        !(function(e2, t2, n2, r2, o, i, u2, s, f2) {
          var a2;
          l.exports = a2 || function(e3) {
            for (var t3, n3 = new Array(e3), r3 = 0; r3 < e3; r3++) 0 == (3 & r3) && (t3 = 4294967296 * Math.random()), n3[r3] = t3 >>> ((3 & r3) << 3) & 255;
            return n3;
          };
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 8: [function(c2, d, e) {
        !(function(e2, t, n2, r2, o, s, a2, f2, l) {
          var i = c2("./helpers");
          function u2(l2, c3) {
            l2[c3 >> 5] |= 128 << 24 - c3 % 32, l2[15 + (c3 + 64 >> 9 << 4)] = c3;
            for (var e3, t2, n3, r3 = Array(80), o2 = 1732584193, i2 = -271733879, u3 = -1732584194, s2 = 271733878, d2 = -1009589776, h = 0; h < l2.length; h += 16) {
              for (var p = o2, g2 = i2, y2 = u3, w = s2, b2 = d2, a3 = 0; a3 < 80; a3++) {
                r3[a3] = a3 < 16 ? l2[h + a3] : v2(r3[a3 - 3] ^ r3[a3 - 8] ^ r3[a3 - 14] ^ r3[a3 - 16], 1);
                var f3 = m2(m2(v2(o2, 5), (f3 = i2, t2 = u3, n3 = s2, (e3 = a3) < 20 ? f3 & t2 | ~f3 & n3 : !(e3 < 40) && e3 < 60 ? f3 & t2 | f3 & n3 | t2 & n3 : f3 ^ t2 ^ n3)), m2(m2(d2, r3[a3]), (e3 = a3) < 20 ? 1518500249 : e3 < 40 ? 1859775393 : e3 < 60 ? -1894007588 : -899497514)), d2 = s2, s2 = u3, u3 = v2(i2, 30), i2 = o2, o2 = f3;
              }
              o2 = m2(o2, p), i2 = m2(i2, g2), u3 = m2(u3, y2), s2 = m2(s2, w), d2 = m2(d2, b2);
            }
            return Array(o2, i2, u3, s2, d2);
          }
          function m2(e3, t2) {
            var n3 = (65535 & e3) + (65535 & t2);
            return (e3 >> 16) + (t2 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
          }
          function v2(e3, t2) {
            return e3 << t2 | e3 >>> 32 - t2;
          }
          d.exports = function(e3) {
            return i.hash(e3, u2, 20, true);
          };
        }).call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(c2, d, e) {
        !(function(e2, t, n2, r2, u2, s, a2, f2, l) {
          function b2(e3, t2) {
            var n3 = (65535 & e3) + (65535 & t2);
            return (e3 >> 16) + (t2 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
          }
          function o(e3, l2) {
            var c3, d2 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), t2 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), n3 = new Array(64);
            e3[l2 >> 5] |= 128 << 24 - l2 % 32, e3[15 + (l2 + 64 >> 9 << 4)] = l2;
            for (var r3, o2, h = 0; h < e3.length; h += 16) {
              for (var i2 = t2[0], u3 = t2[1], s2 = t2[2], p = t2[3], a3 = t2[4], g2 = t2[5], y2 = t2[6], w = t2[7], f3 = 0; f3 < 64; f3++) n3[f3] = f3 < 16 ? e3[f3 + h] : b2(b2(b2((o2 = n3[f3 - 2], m2(o2, 17) ^ m2(o2, 19) ^ v2(o2, 10)), n3[f3 - 7]), (o2 = n3[f3 - 15], m2(o2, 7) ^ m2(o2, 18) ^ v2(o2, 3))), n3[f3 - 16]), c3 = b2(b2(b2(b2(w, m2(o2 = a3, 6) ^ m2(o2, 11) ^ m2(o2, 25)), a3 & g2 ^ ~a3 & y2), d2[f3]), n3[f3]), r3 = b2(m2(r3 = i2, 2) ^ m2(r3, 13) ^ m2(r3, 22), i2 & u3 ^ i2 & s2 ^ u3 & s2), w = y2, y2 = g2, g2 = a3, a3 = b2(p, c3), p = s2, s2 = u3, u3 = i2, i2 = b2(c3, r3);
              t2[0] = b2(i2, t2[0]), t2[1] = b2(u3, t2[1]), t2[2] = b2(s2, t2[2]), t2[3] = b2(p, t2[3]), t2[4] = b2(a3, t2[4]), t2[5] = b2(g2, t2[5]), t2[6] = b2(y2, t2[6]), t2[7] = b2(w, t2[7]);
            }
            return t2;
          }
          var i = c2("./helpers"), m2 = function(e3, t2) {
            return e3 >>> t2 | e3 << 32 - t2;
          }, v2 = function(e3, t2) {
            return e3 >>> t2;
          };
          d.exports = function(e3) {
            return i.hash(e3, o, 32, true);
          };
        }).call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(e, t, f2) {
        !(function(e2, t2, n2, r2, o, i, u2, s, a2) {
          f2.read = function(e3, t3, n3, r3, o2) {
            var i2, u3, l = 8 * o2 - r3 - 1, c2 = (1 << l) - 1, d = c2 >> 1, s2 = -7, a3 = n3 ? o2 - 1 : 0, f3 = n3 ? -1 : 1, o2 = e3[t3 + a3];
            for (a3 += f3, i2 = o2 & (1 << -s2) - 1, o2 >>= -s2, s2 += l; 0 < s2; i2 = 256 * i2 + e3[t3 + a3], a3 += f3, s2 -= 8) ;
            for (u3 = i2 & (1 << -s2) - 1, i2 >>= -s2, s2 += r3; 0 < s2; u3 = 256 * u3 + e3[t3 + a3], a3 += f3, s2 -= 8) ;
            if (0 === i2) i2 = 1 - d;
            else {
              if (i2 === c2) return u3 ? NaN : 1 / 0 * (o2 ? -1 : 1);
              u3 += Math.pow(2, r3), i2 -= d;
            }
            return (o2 ? -1 : 1) * u3 * Math.pow(2, i2 - r3);
          }, f2.write = function(e3, t3, l, n3, r3, c2) {
            var o2, i2, u3 = 8 * c2 - r3 - 1, s2 = (1 << u3) - 1, a3 = s2 >> 1, d = 23 === r3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f3 = n3 ? 0 : c2 - 1, h = n3 ? 1 : -1, c2 = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
            for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (i2 = isNaN(t3) ? 1 : 0, o2 = s2) : (o2 = Math.floor(Math.log(t3) / Math.LN2), t3 * (n3 = Math.pow(2, -o2)) < 1 && (o2--, n3 *= 2), 2 <= (t3 += 1 <= o2 + a3 ? d / n3 : d * Math.pow(2, 1 - a3)) * n3 && (o2++, n3 /= 2), s2 <= o2 + a3 ? (i2 = 0, o2 = s2) : 1 <= o2 + a3 ? (i2 = (t3 * n3 - 1) * Math.pow(2, r3), o2 += a3) : (i2 = t3 * Math.pow(2, a3 - 1) * Math.pow(2, r3), o2 = 0)); 8 <= r3; e3[l + f3] = 255 & i2, f3 += h, i2 /= 256, r3 -= 8) ;
            for (o2 = o2 << r3 | i2, u3 += r3; 0 < u3; e3[l + f3] = 255 & o2, f3 += h, o2 /= 256, u3 -= 8) ;
            e3[l + f3 - h] |= 128 * c2;
          };
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
      }, { buffer: 3, lYpoI2: 11 }], 11: [function(e, h, t) {
        !(function(e2, t2, n2, r2, o, f2, l, c2, d) {
          var i, u2, s;
          function a2() {
          }
          (e2 = h.exports = {}).nextTick = (u2 = "undefined" != typeof window && window.setImmediate, s = "undefined" != typeof window && window.postMessage && window.addEventListener, u2 ? function(e3) {
            return window.setImmediate(e3);
          } : s ? (i = [], window.addEventListener("message", function(e3) {
            var t3 = e3.source;
            t3 !== window && null !== t3 || "process-tick" !== e3.data || (e3.stopPropagation(), 0 < i.length && i.shift()());
          }, true), function(e3) {
            i.push(e3), window.postMessage("process-tick", "*");
          }) : function(e3) {
            setTimeout(e3, 0);
          }), e2.title = "browser", e2.browser = true, e2.env = {}, e2.argv = [], e2.on = a2, e2.addListener = a2, e2.once = a2, e2.off = a2, e2.removeListener = a2, e2.removeAllListeners = a2, e2.emit = a2, e2.binding = function(e3) {
            throw new Error("process.binding is not supported");
          }, e2.cwd = function() {
            return "/";
          }, e2.chdir = function(e3) {
            throw new Error("process.chdir is not supported");
          };
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
      }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
    });
  }
});

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v2;
  return Uint8Array.of((v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24, v2 >>> 16 & 255, v2 >>> 8 & 255, v2 & 255, (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8, v2 & 255, (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8, v2 & 255, (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8, v2 & 255, (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v2 / 4294967296 & 255, v2 >>> 24 & 255, v2 >>> 16 & 255, v2 >>> 8 & 255, v2 & 255);
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i = 0; i < input.length * 4; i++) {
    bytes[i] = input[i >> 2] >>> i % 4 * 8 & 255;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x2, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x2);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x2 = xpad;
  let a2 = 1732584193;
  let b2 = -271733879;
  let c2 = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x2.length; i += 16) {
    const olda = a2;
    const oldb = b2;
    const oldc = c2;
    const oldd = d;
    a2 = md5ff(a2, b2, c2, d, x2[i], 7, -680876936);
    d = md5ff(d, a2, b2, c2, x2[i + 1], 12, -389564586);
    c2 = md5ff(c2, d, a2, b2, x2[i + 2], 17, 606105819);
    b2 = md5ff(b2, c2, d, a2, x2[i + 3], 22, -1044525330);
    a2 = md5ff(a2, b2, c2, d, x2[i + 4], 7, -176418897);
    d = md5ff(d, a2, b2, c2, x2[i + 5], 12, 1200080426);
    c2 = md5ff(c2, d, a2, b2, x2[i + 6], 17, -1473231341);
    b2 = md5ff(b2, c2, d, a2, x2[i + 7], 22, -45705983);
    a2 = md5ff(a2, b2, c2, d, x2[i + 8], 7, 1770035416);
    d = md5ff(d, a2, b2, c2, x2[i + 9], 12, -1958414417);
    c2 = md5ff(c2, d, a2, b2, x2[i + 10], 17, -42063);
    b2 = md5ff(b2, c2, d, a2, x2[i + 11], 22, -1990404162);
    a2 = md5ff(a2, b2, c2, d, x2[i + 12], 7, 1804603682);
    d = md5ff(d, a2, b2, c2, x2[i + 13], 12, -40341101);
    c2 = md5ff(c2, d, a2, b2, x2[i + 14], 17, -1502002290);
    b2 = md5ff(b2, c2, d, a2, x2[i + 15], 22, 1236535329);
    a2 = md5gg(a2, b2, c2, d, x2[i + 1], 5, -165796510);
    d = md5gg(d, a2, b2, c2, x2[i + 6], 9, -1069501632);
    c2 = md5gg(c2, d, a2, b2, x2[i + 11], 14, 643717713);
    b2 = md5gg(b2, c2, d, a2, x2[i], 20, -373897302);
    a2 = md5gg(a2, b2, c2, d, x2[i + 5], 5, -701558691);
    d = md5gg(d, a2, b2, c2, x2[i + 10], 9, 38016083);
    c2 = md5gg(c2, d, a2, b2, x2[i + 15], 14, -660478335);
    b2 = md5gg(b2, c2, d, a2, x2[i + 4], 20, -405537848);
    a2 = md5gg(a2, b2, c2, d, x2[i + 9], 5, 568446438);
    d = md5gg(d, a2, b2, c2, x2[i + 14], 9, -1019803690);
    c2 = md5gg(c2, d, a2, b2, x2[i + 3], 14, -187363961);
    b2 = md5gg(b2, c2, d, a2, x2[i + 8], 20, 1163531501);
    a2 = md5gg(a2, b2, c2, d, x2[i + 13], 5, -1444681467);
    d = md5gg(d, a2, b2, c2, x2[i + 2], 9, -51403784);
    c2 = md5gg(c2, d, a2, b2, x2[i + 7], 14, 1735328473);
    b2 = md5gg(b2, c2, d, a2, x2[i + 12], 20, -1926607734);
    a2 = md5hh(a2, b2, c2, d, x2[i + 5], 4, -378558);
    d = md5hh(d, a2, b2, c2, x2[i + 8], 11, -2022574463);
    c2 = md5hh(c2, d, a2, b2, x2[i + 11], 16, 1839030562);
    b2 = md5hh(b2, c2, d, a2, x2[i + 14], 23, -35309556);
    a2 = md5hh(a2, b2, c2, d, x2[i + 1], 4, -1530992060);
    d = md5hh(d, a2, b2, c2, x2[i + 4], 11, 1272893353);
    c2 = md5hh(c2, d, a2, b2, x2[i + 7], 16, -155497632);
    b2 = md5hh(b2, c2, d, a2, x2[i + 10], 23, -1094730640);
    a2 = md5hh(a2, b2, c2, d, x2[i + 13], 4, 681279174);
    d = md5hh(d, a2, b2, c2, x2[i], 11, -358537222);
    c2 = md5hh(c2, d, a2, b2, x2[i + 3], 16, -722521979);
    b2 = md5hh(b2, c2, d, a2, x2[i + 6], 23, 76029189);
    a2 = md5hh(a2, b2, c2, d, x2[i + 9], 4, -640364487);
    d = md5hh(d, a2, b2, c2, x2[i + 12], 11, -421815835);
    c2 = md5hh(c2, d, a2, b2, x2[i + 15], 16, 530742520);
    b2 = md5hh(b2, c2, d, a2, x2[i + 2], 23, -995338651);
    a2 = md5ii(a2, b2, c2, d, x2[i], 6, -198630844);
    d = md5ii(d, a2, b2, c2, x2[i + 7], 10, 1126891415);
    c2 = md5ii(c2, d, a2, b2, x2[i + 14], 15, -1416354905);
    b2 = md5ii(b2, c2, d, a2, x2[i + 5], 21, -57434055);
    a2 = md5ii(a2, b2, c2, d, x2[i + 12], 6, 1700485571);
    d = md5ii(d, a2, b2, c2, x2[i + 3], 10, -1894986606);
    c2 = md5ii(c2, d, a2, b2, x2[i + 10], 15, -1051523);
    b2 = md5ii(b2, c2, d, a2, x2[i + 1], 21, -2054922799);
    a2 = md5ii(a2, b2, c2, d, x2[i + 8], 6, 1873313359);
    d = md5ii(d, a2, b2, c2, x2[i + 15], 10, -30611744);
    c2 = md5ii(c2, d, a2, b2, x2[i + 6], 15, -1560198380);
    b2 = md5ii(b2, c2, d, a2, x2[i + 13], 21, 1309151649);
    a2 = md5ii(a2, b2, c2, d, x2[i + 4], 6, -145523070);
    d = md5ii(d, a2, b2, c2, x2[i + 11], 10, -1120210379);
    c2 = md5ii(c2, d, a2, b2, x2[i + 2], 15, 718787259);
    b2 = md5ii(b2, c2, d, a2, x2[i + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b2 = safeAdd(b2, oldb);
    c2 = safeAdd(c2, oldc);
    d = safeAdd(d, oldd);
  }
  return Uint32Array.of(a2, b2, c2, d);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i = 0; i < input.length; i++) {
    output[i >> 2] |= (input[i] & 255) << i % 4 * 8;
  }
  return output;
}
function safeAdd(x2, y2) {
  const lsw = (x2 & 65535) + (y2 & 65535);
  const msw = (x2 >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q2, a2, b2, x2, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q2), safeAdd(x2, t)), s), b2);
}
function md5ff(a2, b2, c2, d, x2, s, t) {
  return md5cmn(b2 & c2 | ~b2 & d, a2, b2, x2, s, t);
}
function md5gg(a2, b2, c2, d, x2, s, t) {
  return md5cmn(b2 & d | c2 & ~d, a2, b2, x2, s, t);
}
function md5hh(a2, b2, c2, d, x2, s, t) {
  return md5cmn(b2 ^ c2 ^ d, a2, b2, x2, s, t);
}
function md5ii(a2, b2, c2, d, x2, s, t) {
  return md5cmn(c2 ^ (b2 | ~d), a2, b2, x2, s, t);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(version, hash, value, namespace, buf, offset) {
  const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if ((namespace == null ? void 0 : namespace.length) !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 15 | version;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}

// node_modules/uuid/dist/esm-browser/v3.js
function v3(value, namespace, buf, offset) {
  return v35(48, md5_default, value, namespace, buf, offset);
}
v3.DNS = DNS;
v3.URL = URL;

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  var _a;
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? ((_a = options.rng) == null ? void 0 : _a.call(options)) ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x2, y2, z2) {
  switch (s) {
    case 0:
      return x2 & y2 ^ ~x2 & z2;
    case 1:
      return x2 ^ y2 ^ z2;
    case 2:
      return x2 & y2 ^ x2 & z2 ^ y2 & z2;
    case 3:
      return x2 ^ y2 ^ z2;
  }
}
function ROTL(x2, n2) {
  return x2 << n2 | x2 >>> 32 - n2;
}
function sha1(bytes) {
  const K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 128;
  bytes = newBytes;
  const l = bytes.length / 4 + 2;
  const N2 = Math.ceil(l / 16);
  const M2 = new Array(N2);
  for (let i = 0; i < N2; ++i) {
    const arr = new Uint32Array(16);
    for (let j2 = 0; j2 < 16; ++j2) {
      arr[j2] = bytes[i * 64 + j2 * 4] << 24 | bytes[i * 64 + j2 * 4 + 1] << 16 | bytes[i * 64 + j2 * 4 + 2] << 8 | bytes[i * 64 + j2 * 4 + 3];
    }
    M2[i] = arr;
  }
  M2[N2 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M2[N2 - 1][14] = Math.floor(M2[N2 - 1][14]);
  M2[N2 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N2; ++i) {
    const W2 = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W2[t] = M2[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W2[t] = ROTL(W2[t - 3] ^ W2[t - 8] ^ W2[t - 14] ^ W2[t - 16], 1);
    }
    let a2 = H2[0];
    let b2 = H2[1];
    let c2 = H2[2];
    let d = H2[3];
    let e = H2[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a2, 5) + f(s, b2, c2, d) + e + K2[s] + W2[t] >>> 0;
      e = d;
      d = c2;
      c2 = ROTL(b2, 30) >>> 0;
      b2 = a2;
      a2 = T;
    }
    H2[0] = H2[0] + a2 >>> 0;
    H2[1] = H2[1] + b2 >>> 0;
    H2[2] = H2[2] + c2 >>> 0;
    H2[3] = H2[3] + d >>> 0;
    H2[4] = H2[4] + e >>> 0;
  }
  return Uint8Array.of(H2[0] >> 24, H2[0] >> 16, H2[0] >> 8, H2[0], H2[1] >> 24, H2[1] >> 16, H2[1] >> 8, H2[1], H2[2] >> 24, H2[2] >> 16, H2[2] >> 8, H2[2], H2[3] >> 24, H2[3] >> 16, H2[3] >> 8, H2[3], H2[4] >> 24, H2[4] >> 16, H2[4] >> 8, H2[4]);
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
function v5(value, namespace, buf, offset) {
  return v35(80, sha1_default, value, namespace, buf, offset);
}
v5.DNS = DNS;
v5.URL = URL;

// node_modules/@lumi.new/sdk/dist/index.mjs
var import_enc_base64 = __toESM(require_enc_base64(), 1);
var import_enc_hex = __toESM(require_enc_hex(), 1);
var import_hmac_sha256 = __toESM(require_hmac_sha256(), 1);
var import_sha256 = __toESM(require_sha256(), 1);
var import_object_hash = __toESM(require_object_hash(), 1);

// node_modules/destr/dist/index.mjs
var suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
    return value.slice(1, -1);
  }
  const _value = value.trim();
  if (_value.length <= 9) {
    switch (_value.toLowerCase()) {
      case "true": {
        return true;
      }
      case "false": {
        return false;
      }
      case "undefined": {
        return void 0;
      }
      case "null": {
        return null;
      }
      case "nan": {
        return Number.NaN;
      }
      case "infinity": {
        return Number.POSITIVE_INFINITY;
      }
      case "-infinity": {
        return Number.NEGATIVE_INFINITY;
      }
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

// node_modules/ufo/dist/index.mjs
var r = String.fromCharCode;
var HASH_RE = /#/g;
var AMPERSAND_RE = /&/g;
var SLASH_RE = /\//g;
var EQUAL_RE = /=/g;
var PLUS_RE = /\+/g;
var ENC_CARET_RE = /%5e/gi;
var ENC_BACKTICK_RE = /%60/gi;
var ENC_PIPE_RE = /%7c/gi;
var ENC_SPACE_RE = /%20/gi;
function encode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|");
}
function encodeQueryValue(input) {
  return encode(typeof input === "string" ? input : JSON.stringify(input)).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CARET_RE, "^").replace(SLASH_RE, "%2F");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function decode(text = "") {
  try {
    return decodeURIComponent("" + text);
  } catch {
    return "" + text;
  }
}
function decodeQueryKey(text) {
  return decode(text.replace(PLUS_RE, " "));
}
function decodeQueryValue(text) {
  return decode(text.replace(PLUS_RE, " "));
}
function parseQuery(parametersString = "") {
  const object = /* @__PURE__ */ Object.create(null);
  if (parametersString[0] === "?") {
    parametersString = parametersString.slice(1);
  }
  for (const parameter of parametersString.split("&")) {
    const s = parameter.match(/([^=]+)=?(.*)/) || [];
    if (s.length < 2) {
      continue;
    }
    const key = decodeQueryKey(s[1]);
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = decodeQueryValue(s[2] || "");
    if (object[key] === void 0) {
      object[key] = value;
    } else if (Array.isArray(object[key])) {
      object[key].push(value);
    } else {
      object[key] = [object[key], value];
    }
  }
  return object;
}
function encodeQueryItem(key, value) {
  if (typeof value === "number" || typeof value === "boolean") {
    value = String(value);
  }
  if (!value) {
    return encodeQueryKey(key);
  }
  if (Array.isArray(value)) {
    return value.map(
      (_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`
    ).join("&");
  }
  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;
}
function stringifyQuery(query) {
  return Object.keys(query).filter((k2) => query[k2] !== void 0).map((k2) => encodeQueryItem(k2, query[k2])).filter(Boolean).join("&");
}
var PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/;
var PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/;
var PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/;
var TRAILING_SLASH_RE = /\/$|\/\?|\/#/;
var JOIN_LEADING_SLASH_RE = /^\.?\//;
function hasProtocol(inputString, opts = {}) {
  if (typeof opts === "boolean") {
    opts = { acceptRelative: opts };
  }
  if (opts.strict) {
    return PROTOCOL_STRICT_REGEX.test(inputString);
  }
  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);
}
function hasTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/");
  }
  return TRAILING_SLASH_RE.test(input);
}
function withoutTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || "/";
  }
  if (!hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex !== -1) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
  }
  const [s0, ...s] = path.split("?");
  const cleanPath = s0.endsWith("/") ? s0.slice(0, -1) : s0;
  return (cleanPath || "/") + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function withTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/") ? input : input + "/";
  }
  if (hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex !== -1) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
    if (!path) {
      return fragment;
    }
  }
  const [s0, ...s] = path.split("?");
  return s0 + "/" + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function withBase(input, base) {
  if (isEmptyURL(base) || hasProtocol(input)) {
    return input;
  }
  const _base = withoutTrailingSlash(base);
  if (input.startsWith(_base)) {
    return input;
  }
  return joinURL(_base, input);
}
function withQuery(input, query) {
  const parsed = parseURL(input);
  const mergedQuery = { ...parseQuery(parsed.search), ...query };
  parsed.search = stringifyQuery(mergedQuery);
  return stringifyParsedURL(parsed);
}
function isEmptyURL(url) {
  return !url || url === "/";
}
function isNonEmptyURL(url) {
  return url && url !== "/";
}
function joinURL(base, ...input) {
  let url = base || "";
  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {
    if (url) {
      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
      url = withTrailingSlash(url) + _segment;
    } else {
      url = segment;
    }
  }
  return url;
}
var protocolRelative = Symbol.for("ufo:protocolRelative");
function parseURL(input = "", defaultProto) {
  const _specialProtoMatch = input.match(
    /^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i
  );
  if (_specialProtoMatch) {
    const [, _proto, _pathname = ""] = _specialProtoMatch;
    return {
      protocol: _proto.toLowerCase(),
      pathname: _pathname,
      href: _proto + _pathname,
      auth: "",
      host: "",
      search: "",
      hash: ""
    };
  }
  if (!hasProtocol(input, { acceptRelative: true })) {
    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);
  }
  const [, protocol = "", auth, hostAndPath = ""] = input.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
  let [, host = "", path = ""] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];
  if (protocol === "file:") {
    path = path.replace(/\/(?=[A-Za-z]:)/, "");
  }
  const { pathname, search, hash } = parsePath(path);
  return {
    protocol: protocol.toLowerCase(),
    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : "",
    host,
    pathname,
    search,
    hash,
    [protocolRelative]: !protocol
  };
}
function parsePath(input = "") {
  const [pathname = "", search = "", hash = ""] = (input.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
  return {
    pathname,
    search,
    hash
  };
}
function stringifyParsedURL(parsed) {
  const pathname = parsed.pathname || "";
  const search = parsed.search ? (parsed.search.startsWith("?") ? "" : "?") + parsed.search : "";
  const hash = parsed.hash || "";
  const auth = parsed.auth ? parsed.auth + "@" : "";
  const host = parsed.host || "";
  const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || "") + "//" : "";
  return proto + auth + host + pathname + search + hash;
}

// node_modules/ofetch/dist/shared/ofetch.03887fc3.mjs
var FetchError = class extends Error {
  constructor(message, opts) {
    super(message, opts);
    this.name = "FetchError";
    if ((opts == null ? void 0 : opts.cause) && !this.cause) {
      this.cause = opts.cause;
    }
  }
};
function createFetchError(ctx) {
  var _a, _b, _c, _d, _e;
  const errorMessage = ((_a = ctx.error) == null ? void 0 : _a.message) || ((_b = ctx.error) == null ? void 0 : _b.toString()) || "";
  const method = ((_c = ctx.request) == null ? void 0 : _c.method) || ((_d = ctx.options) == null ? void 0 : _d.method) || "GET";
  const url = ((_e = ctx.request) == null ? void 0 : _e.url) || String(ctx.request) || "/";
  const requestStr = `[${method}] ${JSON.stringify(url)}`;
  const statusStr = ctx.response ? `${ctx.response.status} ${ctx.response.statusText}` : "<no response>";
  const message = `${requestStr}: ${statusStr}${errorMessage ? ` ${errorMessage}` : ""}`;
  const fetchError = new FetchError(
    message,
    ctx.error ? { cause: ctx.error } : void 0
  );
  for (const key of ["request", "options", "response"]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx[key];
      }
    });
  }
  for (const [key, refKey] of [
    ["data", "_data"],
    ["status", "status"],
    ["statusCode", "status"],
    ["statusText", "statusText"],
    ["statusMessage", "statusText"]
  ]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx.response && ctx.response[refKey];
      }
    });
  }
  return fetchError;
}
var payloadMethods = new Set(
  Object.freeze(["PATCH", "POST", "PUT", "DELETE"])
);
function isPayloadMethod(method = "GET") {
  return payloadMethods.has(method.toUpperCase());
}
function isJSONSerializable(value) {
  if (value === void 0) {
    return false;
  }
  const t = typeof value;
  if (t === "string" || t === "number" || t === "boolean" || t === null) {
    return true;
  }
  if (t !== "object") {
    return false;
  }
  if (Array.isArray(value)) {
    return true;
  }
  if (value.buffer) {
    return false;
  }
  return value.constructor && value.constructor.name === "Object" || typeof value.toJSON === "function";
}
var textTypes = /* @__PURE__ */ new Set([
  "image/svg",
  "application/xml",
  "application/xhtml",
  "application/html"
]);
var JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function detectResponseType(_contentType = "") {
  if (!_contentType) {
    return "json";
  }
  const contentType = _contentType.split(";").shift() || "";
  if (JSON_RE.test(contentType)) {
    return "json";
  }
  if (textTypes.has(contentType) || contentType.startsWith("text/")) {
    return "text";
  }
  return "blob";
}
function resolveFetchOptions(request, input, defaults, Headers3) {
  const headers = mergeHeaders(
    (input == null ? void 0 : input.headers) ?? (request == null ? void 0 : request.headers),
    defaults == null ? void 0 : defaults.headers,
    Headers3
  );
  let query;
  if ((defaults == null ? void 0 : defaults.query) || (defaults == null ? void 0 : defaults.params) || (input == null ? void 0 : input.params) || (input == null ? void 0 : input.query)) {
    query = {
      ...defaults == null ? void 0 : defaults.params,
      ...defaults == null ? void 0 : defaults.query,
      ...input == null ? void 0 : input.params,
      ...input == null ? void 0 : input.query
    };
  }
  return {
    ...defaults,
    ...input,
    query,
    params: query,
    headers
  };
}
function mergeHeaders(input, defaults, Headers3) {
  if (!defaults) {
    return new Headers3(input);
  }
  const headers = new Headers3(defaults);
  if (input) {
    for (const [key, value] of Symbol.iterator in input || Array.isArray(input) ? input : new Headers3(input)) {
      headers.set(key, value);
    }
  }
  return headers;
}
async function callHooks(context, hooks) {
  if (hooks) {
    if (Array.isArray(hooks)) {
      for (const hook of hooks) {
        await hook(context);
      }
    } else {
      await hooks(context);
    }
  }
}
var retryStatusCodes = /* @__PURE__ */ new Set([
  408,
  // Request Timeout
  409,
  // Conflict
  425,
  // Too Early (Experimental)
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  // Gateway Timeout
]);
var nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);
function createFetch(globalOptions = {}) {
  const {
    fetch: fetch2 = globalThis.fetch,
    Headers: Headers3 = globalThis.Headers,
    AbortController: AbortController2 = globalThis.AbortController
  } = globalOptions;
  async function onError(context) {
    const isAbort = context.error && context.error.name === "AbortError" && !context.options.timeout || false;
    if (context.options.retry !== false && !isAbort) {
      let retries;
      if (typeof context.options.retry === "number") {
        retries = context.options.retry;
      } else {
        retries = isPayloadMethod(context.options.method) ? 0 : 1;
      }
      const responseCode = context.response && context.response.status || 500;
      if (retries > 0 && (Array.isArray(context.options.retryStatusCodes) ? context.options.retryStatusCodes.includes(responseCode) : retryStatusCodes.has(responseCode))) {
        const retryDelay = typeof context.options.retryDelay === "function" ? context.options.retryDelay(context) : context.options.retryDelay || 0;
        if (retryDelay > 0) {
          await new Promise((resolve) => setTimeout(resolve, retryDelay));
        }
        return $fetchRaw(context.request, {
          ...context.options,
          retry: retries - 1
        });
      }
    }
    const error = createFetchError(context);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(error, $fetchRaw);
    }
    throw error;
  }
  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {
    const context = {
      request: _request,
      options: resolveFetchOptions(
        _request,
        _options,
        globalOptions.defaults,
        Headers3
      ),
      response: void 0,
      error: void 0
    };
    if (context.options.method) {
      context.options.method = context.options.method.toUpperCase();
    }
    if (context.options.onRequest) {
      await callHooks(context, context.options.onRequest);
    }
    if (typeof context.request === "string") {
      if (context.options.baseURL) {
        context.request = withBase(context.request, context.options.baseURL);
      }
      if (context.options.query) {
        context.request = withQuery(context.request, context.options.query);
        delete context.options.query;
      }
      if ("query" in context.options) {
        delete context.options.query;
      }
      if ("params" in context.options) {
        delete context.options.params;
      }
    }
    if (context.options.body && isPayloadMethod(context.options.method)) {
      if (isJSONSerializable(context.options.body)) {
        context.options.body = typeof context.options.body === "string" ? context.options.body : JSON.stringify(context.options.body);
        context.options.headers = new Headers3(context.options.headers || {});
        if (!context.options.headers.has("content-type")) {
          context.options.headers.set("content-type", "application/json");
        }
        if (!context.options.headers.has("accept")) {
          context.options.headers.set("accept", "application/json");
        }
      } else if (
        // ReadableStream Body
        "pipeTo" in context.options.body && typeof context.options.body.pipeTo === "function" || // Node.js Stream Body
        typeof context.options.body.pipe === "function"
      ) {
        if (!("duplex" in context.options)) {
          context.options.duplex = "half";
        }
      }
    }
    let abortTimeout;
    if (!context.options.signal && context.options.timeout) {
      const controller = new AbortController2();
      abortTimeout = setTimeout(() => {
        const error = new Error(
          "[TimeoutError]: The operation was aborted due to timeout"
        );
        error.name = "TimeoutError";
        error.code = 23;
        controller.abort(error);
      }, context.options.timeout);
      context.options.signal = controller.signal;
    }
    try {
      context.response = await fetch2(
        context.request,
        context.options
      );
    } catch (error) {
      context.error = error;
      if (context.options.onRequestError) {
        await callHooks(
          context,
          context.options.onRequestError
        );
      }
      return await onError(context);
    } finally {
      if (abortTimeout) {
        clearTimeout(abortTimeout);
      }
    }
    const hasBody = (context.response.body || // https://github.com/unjs/ofetch/issues/324
    // https://github.com/unjs/ofetch/issues/294
    // https://github.com/JakeChampion/fetch/issues/1454
    context.response._bodyInit) && !nullBodyResponses.has(context.response.status) && context.options.method !== "HEAD";
    if (hasBody) {
      const responseType = (context.options.parseResponse ? "json" : context.options.responseType) || detectResponseType(context.response.headers.get("content-type") || "");
      switch (responseType) {
        case "json": {
          const data = await context.response.text();
          const parseFunction = context.options.parseResponse || destr;
          context.response._data = parseFunction(data);
          break;
        }
        case "stream": {
          context.response._data = context.response.body || context.response._bodyInit;
          break;
        }
        default: {
          context.response._data = await context.response[responseType]();
        }
      }
    }
    if (context.options.onResponse) {
      await callHooks(
        context,
        context.options.onResponse
      );
    }
    if (!context.options.ignoreResponseError && context.response.status >= 400 && context.response.status < 600) {
      if (context.options.onResponseError) {
        await callHooks(
          context,
          context.options.onResponseError
        );
      }
      return await onError(context);
    }
    return context.response;
  };
  const $fetch = async function $fetch2(request, options) {
    const r2 = await $fetchRaw(request, options);
    return r2._data;
  };
  $fetch.raw = $fetchRaw;
  $fetch.native = (...args) => fetch2(...args);
  $fetch.create = (defaultOptions = {}, customGlobalOptions = {}) => createFetch({
    ...globalOptions,
    ...customGlobalOptions,
    defaults: {
      ...globalOptions.defaults,
      ...customGlobalOptions.defaults,
      ...defaultOptions
    }
  });
  return $fetch;
}

// node_modules/ofetch/dist/index.mjs
var _globalThis = function() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}();
var fetch = _globalThis.fetch ? (...args) => _globalThis.fetch(...args) : () => Promise.reject(new Error("[ofetch] global.fetch is not supported!"));
var Headers2 = _globalThis.Headers;
var AbortController = _globalThis.AbortController;
var ofetch = createFetch({ fetch, Headers: Headers2, AbortController });

// node_modules/@lumi.new/sdk/dist/index.mjs
var G = Object.defineProperty;
var Y = Object.defineProperties;
var z = Object.getOwnPropertyDescriptors;
var j = Object.getOwnPropertySymbols;
var Z = Object.prototype.hasOwnProperty;
var X = Object.prototype.propertyIsEnumerable;
var H = (i) => {
  throw TypeError(i);
};
var F = (i, e, t) => e in i ? G(i, e, { enumerable: true, configurable: true, writable: true, value: t }) : i[e] = t;
var I = (i, e) => {
  for (var t in e || (e = {})) Z.call(e, t) && F(i, t, e[t]);
  if (j) for (var t of j(e)) X.call(e, t) && F(i, t, e[t]);
  return i;
};
var q = (i, e) => Y(i, z(e));
var K = (i, e, t) => e.has(i) || H("Cannot " + t);
var n = (i, e, t) => (K(i, e, "read from private field"), t ? t.call(i) : e.get(i));
var u = (i, e, t) => e.has(i) ? H("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(i) : e.set(i, t);
var g = (i, e, t, r2) => (K(i, e, "write to private field"), r2 ? r2.call(i, t) : e.set(i, t), t);
var c = (i, e, t) => new Promise((r2, o) => {
  var s = (p) => {
    try {
      h(t.next(p));
    } catch (f2) {
      o(f2);
    }
  }, l = (p) => {
    try {
      h(t.throw(p));
    } catch (f2) {
      o(f2);
    }
  }, h = (p) => p.done ? r2(p.value) : Promise.resolve(p.value).then(s, l);
  h((t = t.apply(i, e)).next());
});
var E = class extends Error {
  constructor(t, r2) {
    super(r2);
    this.name = "LumiError";
    this.code = t;
  }
};
var se = "6QrJZ7pFCmBZAeIJF7IArvkCz+EtzA0RVcpHkiQIsQyhs7QtCS9P+CueZdHfB2OtJcgX3BbqY9pfpWeAVTqCwQ==";
function _(i) {
  return encodeURIComponent(i).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`);
}
function oe(i) {
  return (e) => {
    let { options: t } = e, r2 = Math.floor(Date.now() / 1e3).toString(), o = Math.random().toString(36).substring(2, 15), s = I({}, t.query), l = Object.keys(s).sort().map((w) => `${_(w)}=${_(String(s[w]))}`).join("&"), h = { "x-timestamp": r2, "x-nonce": o }, p = Object.keys(h).sort().map((w) => `${w}:${h[w]}`).join(`
`), f2 = t.body && !(t.body instanceof FormData) ? JSON.stringify(t.body) : "", A = (0, import_sha256.default)(f2).toString(import_enc_hex.default), S = [l, p, A].join(`
`);
    console.warn(`Client-side Canonical Request V3:
`, S);
    let d = import_enc_base64.default.stringify((0, import_hmac_sha256.default)(S, i)), T = new Headers(t.headers);
    Object.entries(h).forEach(([w, V]) => {
      T.set(w, V);
    }), T.set("X-Sign", d), t.headers = T;
  };
}
var B = /* @__PURE__ */ new Map();
function ae(i, e) {
  e.body instanceof FormData && (e = q(I({}, e), { body: Array.from(e.body.entries()) }));
  let t = (0, import_object_hash.default)([i, e]), r2 = Date.now(), o = B.get(t);
  if (o && r2 - o < 1e3) throw new E(429, "Too many requests");
  B.set(t, r2);
}
function a(i, e, t = {}) {
  return i.auth.accessToken && (t.headers = I({ Authorization: `Bearer ${i.auth.accessToken}` }, t.headers)), ae(e, t), ofetch(e, q(I({ baseURL: i.config.apiBaseUrl }, t), { onRequest: oe(se) }));
}
function J() {
  var i, e;
  return (e = (i = document.querySelector('link[rel="icon"]')) == null ? void 0 : i.href) != null ? e : null;
}
function Q() {
  var i;
  return (i = document.title) != null ? i : null;
}
function U(i, e, t = localStorage) {
  let r2 = t.getItem(i), o = e ? JSON.stringify(e) : null;
  o ? t.setItem(i, o) : t.removeItem(i), window.dispatchEvent(new StorageEvent("storage", { key: i, oldValue: r2, newValue: o, storageArea: t }));
}
function N(i, e = localStorage) {
  let t = e.getItem(i);
  try {
    return t ? JSON.parse(t) : null;
  } catch (r2) {
    return null;
  }
}
var y;
var x;
var R = class {
  constructor(e) {
    u(this, y);
    u(this, x, `lumi-auth-${v4_default()}`);
    g(this, y, e);
  }
  get accessToken() {
    return N("lumi-access-token");
  }
  set accessToken(e) {
    U("lumi-access-token", e);
  }
  get user() {
    return N("lumi-user");
  }
  set user(e) {
    U("lumi-user", e);
  }
  get isAuthenticated() {
    return !!this.accessToken;
  }
  signIn() {
    let r2 = (window.screen.width - 800) / 2, o = (window.screen.height - 600) / 2, s = window.open(n(this, y).config.authOrigin, n(this, x), `width=800,height=600,left=${r2},top=${o}`), l;
    return new Promise((h, p) => {
      if (!s) return p(new Error("Open auth window failed"));
      let f2 = setInterval(() => {
        s.closed && p(new Error("Auth window closed"));
      }, 1e3), A = (d) => {
        s.closed || (s.focus(), d.stopPropagation(), d.preventDefault());
      }, S = ({ data: d, origin: T, source: w }) => {
        if (!(T !== n(this, y).config.authOrigin || w !== s)) switch (d == null ? void 0 : d.type) {
          case "lumi-ready": {
            s.postMessage({ type: "lumi-init", data: { projectId: n(this, y).config.projectId, icon: J(), title: Q() } }, n(this, y).config.authOrigin);
            break;
          }
          case "lumi-sign-in": {
            if (d.data.projectId !== n(this, y).config.projectId) break;
            s.close(), window.focus(), this.accessToken = d.data.accessToken, this.user = d.data.user, h(d.data);
            break;
          }
        }
      };
      window.addEventListener("message", S), document.addEventListener("click", A, true), l = () => {
        clearInterval(f2), window.removeEventListener("message", S), document.removeEventListener("click", A, true);
      };
    }).finally(() => l == null ? void 0 : l());
  }
  signOut() {
    this.accessToken = null, this.user = null;
  }
  refreshUser() {
    return c(this, null, function* () {
      let e = yield a(n(this, y), "/lm/user/info", { method: "POST" });
      if (e.code !== 200) throw new Error(e.message);
      return this.user = e.data, e.data;
    });
  }
  onAuthChange(e) {
    let t = (r2) => {
      (r2.key === "lumi-access-token" || r2.key === "lumi-user" || r2.key === null) && e({ isAuthenticated: this.isAuthenticated, user: this.user });
    };
    return window.addEventListener("storage", t), () => {
      window.removeEventListener("storage", t);
    };
  }
};
y = /* @__PURE__ */ new WeakMap(), x = /* @__PURE__ */ new WeakMap();
var m;
var v = class {
  constructor(e, t) {
    u(this, m);
    g(this, m, e), this.entityName = t;
  }
  list() {
    return c(this, arguments, function* ({ filter: e, sort: t, limit: r2, skip: o } = {}) {
      if (r2) {
        let s = yield a(n(this, m), this.uri("/find"), { method: "POST", body: { filter: e, sort: t, limit: r2, skip: o } });
        if (s.code !== 200) throw new Error(s.message);
        return s.data;
      } else {
        let s = yield a(n(this, m), this.uri("/list"), { method: "POST", body: { filter: e, sort: t } });
        if (s.code !== 200) throw new Error(s.message);
        return { total: s.data.length, list: s.data };
      }
    });
  }
  get(e) {
    return c(this, null, function* () {
      let t = yield a(n(this, m), this.uri(`/${e}`), { method: "GET" });
      if (t.code !== 200) throw new Error(t.message);
      return t.data;
    });
  }
  create(e) {
    return c(this, null, function* () {
      let t = yield a(n(this, m), this.uri(), { method: "POST", body: e });
      if (t.code !== 200) throw new Error(t.message);
      return t.data;
    });
  }
  createMany(e) {
    return c(this, null, function* () {
      let t = yield a(n(this, m), this.uri("/batch"), { method: "POST", body: e });
      if (t.code !== 200) throw new Error(t.message);
      return t.data;
    });
  }
  update(e, t) {
    return c(this, null, function* () {
      let r2 = yield a(n(this, m), this.uri(), { method: "PUT", body: { filter: { _id: e }, update: t } });
      if (r2.code !== 200) throw new Error(r2.message);
      return r2.data;
    });
  }
  delete(e) {
    return c(this, null, function* () {
      let t = yield a(n(this, m), this.uri(`/${e}`), { method: "DELETE" });
      if (t.code !== 200) throw new Error(t.message);
    });
  }
  deleteMany(e) {
    return c(this, null, function* () {
      let t = yield a(n(this, m), this.uri("/batch-by-ids"), { method: "DELETE", params: { ids: e } });
      if (t.code !== 200) throw new Error(t.message);
    });
  }
  uri(e = "") {
    return `/lm/${n(this, m).config.projectId}/${this.entityName}/documents${e}`;
  }
};
m = /* @__PURE__ */ new WeakMap();
var L;
var P = class {
  constructor(e) {
    u(this, L);
    return g(this, L, e), new Proxy(this, { get(t, r2) {
      return r2 in t || (t[r2] = new v(n(t, L), r2)), t[r2];
    } });
  }
};
L = /* @__PURE__ */ new WeakMap();
var C;
var D = class {
  constructor(e) {
    u(this, C);
    g(this, C, e);
  }
  send(p) {
    return c(this, arguments, function* ({ to: e, subject: t, fromName: r2, html: o, text: s = "", replyTo: l, scheduledAt: h }) {
      if (!e || !t || !o && !s) throw new Error("Failed to send email: Missing required parameters.");
      typeof e == "string" && (e = [e]), typeof l == "string" && (l = [l]);
      let f2 = yield a(n(this, C), `/lm/${n(this, C).config.projectId}/email/send`, { method: "POST", body: { to: e, subject: t, fromName: r2, html: o, text: s, replyTo: l, scheduledAt: h } });
      if (f2.code !== 200) throw new E(f2.code, f2.message);
    });
  }
};
C = /* @__PURE__ */ new WeakMap();
var b;
var M = class {
  constructor(e) {
    u(this, b);
    g(this, b, e);
  }
  upload(e) {
    return c(this, null, function* () {
      let t = new FormData();
      e.forEach((o) => {
        t.append("files", o);
      });
      let r2 = yield a(n(this, b), `/lm/${n(this, b).config.projectId}/file/batch`, { method: "POST", body: t });
      if (r2.code !== 200) throw new E(r2.code, r2.message);
      return r2.data;
    });
  }
  delete(e) {
    return c(this, null, function* () {
      let t = yield a(n(this, b), `/lm/${n(this, b).config.projectId}/file/batch`, { method: "DELETE", body: { fileUrls: e } });
      if (t.code !== 200) throw new E(t.code, t.message);
    });
  }
};
b = /* @__PURE__ */ new WeakMap();
var k;
var O = class {
  constructor(e) {
    u(this, k);
    g(this, k, e), this.email = new D(e), this.file = new M(e);
  }
};
k = /* @__PURE__ */ new WeakMap();
var $ = class {
  constructor(e) {
    this.config = e, this.auth = new R(this), this.entities = new P(this), this.tools = new O(this);
  }
};
function Ge(i) {
  return new $(i);
}
export {
  D as EmailTool,
  P as EntitiesClient,
  v as EntityClient,
  M as FileTool,
  R as LumiAuthClient,
  $ as LumiClient,
  O as ToolsClient,
  Ge as createClient
};
//# sourceMappingURL=@lumi__new_sdk.js.map
